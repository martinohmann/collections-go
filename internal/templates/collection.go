package templates

var Collection = `
// Code generated by collections-gen. DO NOT EDIT.

package {{.Package}}

import (
	"sort"
)

// {{.Name}} is a collection of {{.ItemType}} values.
type {{.Name}} struct {
	items []{{.ItemType}}
}

// New{{.Name}} creates a new collection from a slice of {{.ItemType}}.
func New{{.Name}}(items []{{.ItemType}}) *{{.Name}} {
	return &{{.Name}}{items}
}

// Items returns the underlying slice of {{.ItemType}} values used by the
// collection.
func (c *{{.Name}}) Items() []{{.ItemType}} {
	return c.items
}

func (c *{{.Name}}) EachIndex(fn func({{.ItemType}}, int)) {
	for i, item := range c.items {
		fn(item, i)
	}
}

func (c *{{.Name}}) Each(fn func({{.ItemType}})) {
	c.EachIndex(func(item {{.ItemType}}, _ int) {
		fn(item)
	})
}

func (c *{{.Name}}) IndexOf(el {{.ItemType}}) int {
	for i, item := range c.items {
		if item == el {
			return i
		}
	}

	return -1
}

func (c *{{.Name}}) First() {{.ItemType}} {
	return c.Nth(0)
}

func (c *{{.Name}}) FirstN(n int) *{{.Name}} {
	if n > c.Len() {
		n = c.Len()
	}

	return c.Slice(0, n)
}

func (c *{{.Name}}) Last() {{.ItemType}} {
	return c.Nth(c.Len() - 1)
}

func (c *{{.Name}}) LastN(n int) *{{.Name}} {
	if c.Len()-n < 0 {
		n = c.Len()
	}

	return c.Slice(c.Len()-n, c.Len())
}

func (c *{{.Name}}) Get(idx int) {{.ItemType}} {
	return c.Nth(idx)
}

func (c *{{.Name}}) Nth(idx int) {{.ItemType}} {
	return c.items[idx]
}

func (c *{{.Name}}) Len() int {
	return len(c.items)
}

func (c *{{.Name}}) Cap() int {
	return cap(c.items)
}

func (c *{{.Name}}) Append(items ...{{.ItemType}}) *{{.Name}} {
	c.items = append(c.items, items...)

	return c
}

func (c *{{.Name}}) Prepend(items ...{{.ItemType}}) *{{.Name}} {
	c.items = append(items, c.items...)

	return c
}

func (c *{{.Name}}) Copy() *{{.Name}} {
	s := make([]{{.ItemType}}, c.Len(), c.Len())
	copy(s, c.items)

	return New{{.Name}}(s)
}

func (c *{{.Name}}) Filter(fn func({{.ItemType}}) bool) *{{.Name}} {
	s := c.items[:0]

	for _, item := range c.items {
		if fn(item) {
			s = append(s, item)
		}
	}

	for i := len(s); i < len(c.items); i++ {
		c.items[i] = {{.ZeroValue}}
	}

	c.items = s

	return c
}

func (c *{{.Name}}) Collect(fn func({{.ItemType}}) bool) *{{.Name}} {
	return c.Filter(fn)
}

func (c *{{.Name}}) Reject(fn func({{.ItemType}}) bool) *{{.Name}} {
	return c.Filter(func(v {{.ItemType}}) bool {
		return !fn(v)
	})
}

func (c *{{.Name}}) Partition(fn func({{.ItemType}}) bool) (*{{.Name}}, *{{.Name}}) {
	lhs := make([]{{.ItemType}}, 0, c.Len())
	rhs := make([]{{.ItemType}}, 0, c.Len())

	for _, item := range c.items {
		if fn(item) {
			lhs = append(lhs, item)
		} else {
			rhs = append(rhs, item)
		}
	}

	return New{{.Name}}(lhs), New{{.Name}}(rhs)
}

func (c *{{.Name}}) Map(fn func({{.ItemType}}) {{.ItemType}}) *{{.Name}} {
	for i, item := range c.items {
		c.items[i] = fn(item)

	}

	return c
}

func (c *{{.Name}}) Reduce(fn func(reducer {{.ItemType}}, item {{.ItemType}}) {{.ItemType}}) {{.ItemType}} {
	var reducer {{.ItemType}}

	for _, item := range c.items {
		reducer = fn(reducer, item)
	}

	return reducer
}

func (c *{{.Name}}) Find(fn func({{.ItemType}}) bool) {{.ItemType}} {
	item, _ := c.FindOk(fn)

	return item
}

func (c *{{.Name}}) FindOk(fn func({{.ItemType}}) bool) ({{.ItemType}}, bool) {
	for _, item := range c.items {
		if fn(item) {
			return item, true
		}
	}

	return {{.ZeroValue}}, false
}

func (c *{{.Name}}) Any(fn func({{.ItemType}}) bool) bool {
	for _, item := range c.items {
		if fn(item) {
			return true
		}
	}

	return false
}

func (c *{{.Name}}) All(fn func({{.ItemType}}) bool) bool {
	for _, item := range c.items {
		if !fn(item) {
			return false
		}
	}

	return true
}

func (c *{{.Name}}) Contains(el {{.ItemType}}) bool {
	for _, item := range c.items {
		if item == el {
			return true
		}
	}

	return false
}

func (c *{{.Name}}) Sort(fn func({{.ItemType}}, {{.ItemType}}) bool) *{{.Name}} {
	sort.Slice(c.items, c.lessFunc(fn))

	return c
}

func (c *{{.Name}}) IsSorted(fn func({{.ItemType}}, {{.ItemType}}) bool) bool {
	return sort.SliceIsSorted(c.items, c.lessFunc(fn))
}

func (c *{{.Name}}) lessFunc(fn func({{.ItemType}}, {{.ItemType}}) bool) func(int, int) bool {
	return func(i, j int) bool {
		return fn(c.items[i], c.items[j])
	}
}

func (c *{{.Name}}) Reverse() *{{.Name}} {
	for l, r := 0, len(c.items)-1; l < r; l, r = l+1, r-1 {
		c.items[l], c.items[r] = c.items[r], c.items[l]
	}

	return c
}

func (c *{{.Name}}) Remove(idx int) *{{.Name}} {
	c.items = append(c.items[:idx], c.items[idx+1:]...)

	return c
}

func (c *{{.Name}}) RemoveItem(item {{.ItemType}}) *{{.Name}} {
	for i, el := range c.items {
		if el == item {
			c.items = append(c.items[:i], c.items[i+1:]...)
		}
	}

	return c
}

func (c *{{.Name}}) InsertItem(item {{.ItemType}}, idx int) *{{.Name}} {
	c.items = append(c.items, {{.ZeroValue}})
	copy(c.items[idx+1:], c.items[idx:])
	c.items[idx] = item

	return c
}

func (c *{{.Name}}) Cut(i, j int) *{{.Name}} {
	c.items = append(c.items[:i], c.items[j:]...)

	return c
}

func (c *{{.Name}}) Slice(i, j int) *{{.Name}} {
	c.items = c.items[i:j]

	return c
}
`
