// Code generated by collections-gen. DO NOT EDIT.

package internal

import (
	"sort"
)

type ImmutableCollection struct {
	items []*Type
}

func NewImmutableCollection(items []*Type) *ImmutableCollection {
	return &ImmutableCollection{items}
}

func (c *ImmutableCollection) Items() []*Type {
	return c.items
}

func (c *ImmutableCollection) EachIndex(fn func(*Type, int)) {
	for i, item := range c.items {
		fn(item, i)
	}
}

func (c *ImmutableCollection) Each(fn func(*Type)) {
	c.EachIndex(func(item *Type, _ int) {
		fn(item)
	})
}

func (c *ImmutableCollection) IndexOf(el *Type) int {
	for i, item := range c.items {
		if item == el {
			return i
		}
	}

	return -1
}

func (c *ImmutableCollection) First() *Type {
	return c.Nth(0)
}

func (c *ImmutableCollection) FirstN(n int) *ImmutableCollection {
	if n > c.Len() {
		n = c.Len()
	}

	return c.Slice(0, n)
}

func (c *ImmutableCollection) Last() *Type {
	return c.Nth(c.Len() - 1)
}

func (c *ImmutableCollection) LastN(n int) *ImmutableCollection {
	if c.Len()-n < 0 {
		n = c.Len()
	}

	return c.Slice(c.Len()-n, c.Len())
}

func (c *ImmutableCollection) Get(idx int) *Type {
	return c.Nth(idx)
}

func (c *ImmutableCollection) Nth(idx int) *Type {
	return c.items[idx]
}

func (c *ImmutableCollection) Len() int {
	return len(c.items)
}

func (c *ImmutableCollection) Cap() int {
	return cap(c.items)
}

func (c *ImmutableCollection) Append(items ...*Type) *ImmutableCollection {
	d := c.Copy()
	d.items = append(d.items, items...)

	return d
}

func (c *ImmutableCollection) Prepend(items ...*Type) *ImmutableCollection {
	d := c.Copy()
	d.items = append(items, d.items...)

	return d
}

func (c *ImmutableCollection) Copy() *ImmutableCollection {
	s := make([]*Type, c.Len(), c.Len())
	copy(s, c.items)

	return NewImmutableCollection(s)
}

func (c *ImmutableCollection) Filter(fn func(*Type) bool) *ImmutableCollection {
	d := c.Copy()
	s := d.items[:0]

	for _, item := range d.items {
		if fn(item) {
			s = append(s, item)
		}
	}

	for i := len(s); i < len(d.items); i++ {
		d.items[i] = nil
	}

	d.items = s

	return d
}

func (c *ImmutableCollection) Collect(fn func(*Type) bool) *ImmutableCollection {
	return c.Filter(fn)
}

func (c *ImmutableCollection) Reject(fn func(*Type) bool) *ImmutableCollection {
	return c.Filter(func(v *Type) bool {
		return !fn(v)
	})
}

func (c *ImmutableCollection) Partition(fn func(*Type) bool) (*ImmutableCollection, *ImmutableCollection) {
	lhs := make([]*Type, 0, c.Len())
	rhs := make([]*Type, 0, c.Len())

	for _, item := range c.items {
		if fn(item) {
			lhs = append(lhs, item)
		} else {
			rhs = append(rhs, item)
		}
	}

	return NewImmutableCollection(lhs), NewImmutableCollection(rhs)
}

func (c *ImmutableCollection) Map(fn func(*Type) *Type) *ImmutableCollection {
	d := c.Copy()

	for i, item := range d.items {
		d.items[i] = fn(item)

	}

	return d
}

func (c *ImmutableCollection) Reduce(fn func(reducer *Type, item *Type) *Type) *Type {
	var reducer *Type

	for _, item := range c.items {
		reducer = fn(reducer, item)
	}

	return reducer
}

func (c *ImmutableCollection) Find(fn func(*Type) bool) *Type {
	item, _ := c.FindOk(fn)

	return item
}

func (c *ImmutableCollection) FindOk(fn func(*Type) bool) (*Type, bool) {
	for _, item := range c.items {
		if fn(item) {
			return item, true
		}
	}

	return nil, false
}

func (c *ImmutableCollection) Any(fn func(*Type) bool) bool {
	for _, item := range c.items {
		if fn(item) {
			return true
		}
	}

	return false
}

func (c *ImmutableCollection) All(fn func(*Type) bool) bool {
	for _, item := range c.items {
		if !fn(item) {
			return false
		}
	}

	return true
}

func (c *ImmutableCollection) Contains(el *Type) bool {
	for _, item := range c.items {
		if item == el {
			return true
		}
	}

	return false
}

func (c *ImmutableCollection) Sort(fn func(*Type, *Type) bool) *ImmutableCollection {
	d := c.Copy()
	sort.Slice(d.items, d.lessFunc(fn))

	return d
}

func (c *ImmutableCollection) IsSorted(fn func(*Type, *Type) bool) bool {
	return sort.SliceIsSorted(c.items, c.lessFunc(fn))
}

func (c *ImmutableCollection) lessFunc(fn func(*Type, *Type) bool) func(int, int) bool {
	return func(i, j int) bool {
		return fn(c.items[i], c.items[j])
	}
}

func (c *ImmutableCollection) Reverse() *ImmutableCollection {
	d := c.Copy()
	for l, r := 0, len(d.items)-1; l < r; l, r = l+1, r-1 {
		d.items[l], d.items[r] = d.items[r], d.items[l]
	}

	return d
}

func (c *ImmutableCollection) Remove(idx int) *ImmutableCollection {
	d := c.Copy()
	d.items = append(d.items[:idx], d.items[idx+1:]...)

	return d
}

func (c *ImmutableCollection) RemoveItem(item *Type) *ImmutableCollection {
	d := c.Copy()

	for i, el := range c.items {
		if el == item {
			d.items = append(d.items[:i], d.items[i+1:]...)
		}
	}

	return d
}

func (c *ImmutableCollection) InsertItem(item *Type, idx int) *ImmutableCollection {
	d := c.Copy()
	d.items = append(d.items, nil)
	copy(d.items[idx+1:], d.items[idx:])
	d.items[idx] = item

	return d
}

func (c *ImmutableCollection) Cut(i, j int) *ImmutableCollection {
	d := c.Copy()
	d.items = append(d.items[:i], d.items[j:]...)

	return d
}

func (c *ImmutableCollection) Slice(i, j int) *ImmutableCollection {
	d := c.Copy()
	d.items = d.items[i:j]

	return d
}
